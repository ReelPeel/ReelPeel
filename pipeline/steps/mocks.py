"""
Test-only steps that inject controlled inputs into the pipeline state.

These steps are used in test configs to bypass upstream dependencies
(audio ingestion, transcription, or LLM extraction) and to make downstream
steps reproducible. They do not call external services and only mutate
PipelineState with provided values.

Provided steps and expected config:
- MockTranscriptLoader:
  - config key: transcript_text (str)
  - writes state.transcript and updates state.generated_at
  - logs a warning if transcript_text is missing or empty
- MockStatementLoader:
  - config key: statements (list[dict])
  - each dict may include id, text, and optional query
  - writes state.statements with Statement models and leaves transcript unchanged

Typical usage:
- Use MockTranscriptLoader as Step 1 when testing extraction and downstream steps.
- Use MockStatementLoader to skip extraction and test research/verification logic.
"""

from datetime import datetime

from ..core.base import PipelineStep
from ..core.models import PipelineState, Statement


class MockTranscriptLoader(PipelineStep):
    """
    Injects a predefined transcript into the pipeline state.
    Used for testing downstream steps without needing audio files.
    """

    def execute(self, state: PipelineState) -> PipelineState:
        print(f"[{self.__class__.__name__}] Loading mock transcript...")

        # Get text from the config 'settings'
        mock_text = self.config.get("transcript_text", "")

        if not mock_text:
            print(f"[{self.__class__.__name__}] WARNING: No transcript_text provided in config!")

        state.transcript = mock_text
        # Simulate a timestamp usually generated by Whisper
        state.generated_at = datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

        return state


class MockStatementLoader(PipelineStep):
    """
    Injects specific statements into the pipeline state, skipping extraction.
    Useful for testing Research and Verification logic with controlled claims.
    """

    def execute(self, state: PipelineState) -> PipelineState:
        # Get the list of statement dicts from config
        raw_statements = self.config.get("statements", [])

        if not raw_statements:
            print(f"[WARNING] {self.step_name}: No statements provided in config.")
            return state

        # Convert to Pydantic models
        state.statements = []
        for s in raw_statements:
            # Ensure ID and Text are present, default others
            stmt = Statement(
                id=s.get("id", len(state.statements) + 1),
                text=s.get("text", "Unknown Claim"),
                # You can even pre-fill other fields if testing specific edge cases
                query=s.get("query", None)
            )
            state.statements.append(stmt)

        return state
