from ..core.base import PipelineStep
from ..core.models import PipelineState, Statement
from datetime import datetime


class MockTranscriptLoader(PipelineStep):
    """
    Injects a predefined transcript into the pipeline state.
    Used for testing downstream steps without needing audio files.
    """

    def execute(self, state: PipelineState) -> PipelineState:
        print(f"[{self.__class__.__name__}] Loading mock transcript...")

        # Get text from the config 'settings'
        mock_text = self.config.get("transcript_text", "")

        if not mock_text:
            print(f"[{self.__class__.__name__}] WARNING: No transcript_text provided in config!")

        state.transcript = mock_text
        # Simulate a timestamp usually generated by Whisper
        state.generated_at = datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

        return state


class MockStatementLoader(PipelineStep):
    """
    Injects specific statements into the pipeline state, skipping extraction.
    Useful for testing Research and Verification logic with controlled claims.
    """

    def execute(self, state: PipelineState) -> PipelineState:
        # Get the list of statement dicts from config
        raw_statements = self.config.get("statements", [])

        if not raw_statements:
            print(f"[WARNING] {self.step_name}: No statements provided in config.")
            return state

        # Convert to Pydantic models
        state.statements = []
        for s in raw_statements:
            # Ensure ID and Text are present, default others
            stmt = Statement(
                id=s.get("id", len(state.statements) + 1),
                text=s.get("text", "Unknown Claim"),
                # You can even pre-fill other fields if testing specific edge cases
                query=s.get("query", None)
            )
            state.statements.append(stmt)

        return state